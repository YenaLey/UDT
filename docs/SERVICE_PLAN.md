# Universal Data Translator (UDT)

## 1. 서비스 개요

- **서비스명**: Universal Data Translator (UDT)
- **한줄 소개**: 설정 파일(YAML) 등록 즉시 고유 URL을 생성하여, HTTP 요청 한 번으로 산업용 장비 데이터를 JSON으로 반환하는 'Hardware-to-API' 게이트웨이.
- **핵심 가치**: "복잡한 프로토콜 구현 없이, 설정 파일 하나로 레거시 장비를 REST API 서버로 변환한다."

## 2. 기획 배경 (Pain Point)

- **반복적인 프록시 개발**: 디지털 트윈 프로젝트마다 Modbus, BACnet 등 현장 장비 연결을 위해 별도의 백엔드 서버를 매번 개발해야 하는 비효율 발생.
- **접근성 및 테스트 환경 부재**: 레거시 장비는 HTTP를 지원하지 않아 웹/앱에서 직접 접근이 불가능하며, Postman 같은 도구로 간단히 테스트할 수 없어 검증이 어려움.
- **유지보수의 파편화**: 현장마다 제각각인 하드코딩된 소스 코드로 인해 통합 관리가 불가능하고, 인력 교체 시 막대한 인수인계 비용 발생.

## 3. 핵심 구현 방법 (Core Mechanism)

사용자가 코딩 대신 '선언적 설정(Declarative Configuration)'을 수행하면, 시스템이 '접속용 URL'을 발급하고 요청 시점에 데이터를 가져오는 방식입니다.

1. **등록 (Registration)**: 사용자가 타겟 장비 정보(IP, Port, Protocol, Register)가 담긴 `config.yaml` 파일을 업로드합니다.
2. **생성 (Generation)**: 시스템은 설정을 저장하고, 해당 장비와 1:1로 매핑된 고유 API Endpoint(URL)를 즉시 생성하여 반환합니다.
3. **요청 및 반환 (On-Demand Request)**: 외부(웹/앱)에서 해당 URL로 GET 요청을 보내면, UDT 코어 엔진이 내부적으로 적절한 Docker 컨테이너(프로토콜 어댑터)를 호출하여 실시간 장비 값을 표준 JSON으로 반환합니다.

## 4. 상세 구현 로직 (Architecture)

시스템은 설정 관리자, 요청 라우터, 그리고 무한 확장이 가능한 플러그인 형태의 프로토콜 어댑터로 구성됩니다.

### Step 1: 설정 로드 및 URL 발급 (Admin Context)

- 사용자가 `sensor_config.yaml` (예: `type: modbus-tcp`, `target: 192.168.0.1`)을 업로드합니다.
- 시스템은 고유 ID를 생성하고 `https://api.udt.service/device/{uuid}` 형태의 접속 URL을 사용자에게 부여합니다.

### Step 2: 동적 라우팅 및 어댑터 실행 (User Context)

- 사용자가 발급받은 URL로 데이터 요청(GET)을 보냅니다.
- 라우터는 ID를 기반으로 저장된 설정을 로드하고, `type` 필드를 분석합니다.
- 분석된 타입에 맞는 사전 구축된 Docker 컨테이너(Adapter)를 호출합니다.
- **확장성 핵심**: 새로운 프로토콜(예: Siemens S7, MQTT, KNX)이 필요할 경우, 코어 엔진 수정 없이 해당 프로토콜을 처리하는 도커 이미지만 추가하면 즉시 지원 가능합니다.

### Step 3: 데이터 수집 및 정규화

- 호출된 어댑터 컨테이너가 실제 장비와 통신하여 Raw Data를 수집합니다.
- 수집된 데이터는 코어 엔진을 거쳐 아래와 같은 표준 포맷으로 변환되어 응답합니다.

```json
{
  "request_id": "req_12345",
  "timestamp": "2024-05-20T10:00:00Z",
  "protocol": "modbus",
  "data": { "temperature": 24.5, "status": "running" }
}
```

## 5. 사업성 및 경쟁력 분석

단순한 미들웨어가 아니라 '개발자 경험(DX)을 혁신하는 API 서비스'로서의 가치를 가집니다.

### 5.1. 경쟁 서비스 비교 및 우위

| 구분          | UDT (본 서비스)                | Kepware (PTC)                    | Node-RED               |
| ------------- | ------------------------------ | -------------------------------- | ---------------------- |
| **핵심 컨셉** | Config-to-API (URL 자동생성)   | Industrial Driver Suite          | Visual Flow Coding     |
| **주요 대상** | 웹/앱 개발자, SI 엔지니어      | 공장 자동화(OT) 전문가           | DIY 엔지니어, 메이커   |
| **접근성**    | HTTP REST API (Postman 친화적) | OPC UA/DA (전용 클라이언트 필요) | 독자적인 웹 대시보드   |
| **비용/구조** | 오픈소스/SaaS (Lightweight)    | 고비용 라이선스 (Heavy)          | 무료 (유지보수 어려움) |

### 5.2. 비교 상세

- **vs Kepware**: Kepware는 산업 표준이나, 윈도우 서버 기반으로 무겁고 라이선스 비용이 매우 비쌉니다. UDT는 리눅스/Docker 기반으로 가볍고, 웹 개발자가 선호하는 REST API를 제공하여 진입 장벽을 획기적으로 낮춥니다.
- **vs Node-RED**: Node-RED는 선을 연결하는 코딩 방식으로, 로직이 복잡해지면 '스파게티 코드'가 되어 관리가 불가능합니다. UDT는 yaml 파일 기반의 'Config-as-Code' 방식을 채택하여 Git을 통한 버전 관리와 협업에 최적화되어 있습니다.
- **vs 자체 개발 프록시**: 개발자가 매번 프로토콜 스펙을 공부하고 예외 처리를 구현해야 하는 시간을 '설정 파일 작성 5분'으로 단축시킵니다.

## 6. 구현 가능성 (Technical Feasibility)

본 프로젝트의 핵심인 '다양한 프로토콜 대응'과 '안정성'은 기술적으로 충분히 구현 가능합니다.

### 풍부한 오픈소스 생태계

Modbus(`pymodbus`), BACnet(`bacpypes`) 뿐만 아니라 Siemens S7(`python-snap7`), Ethernet/IP(`cpppo`), KNX(`xknx`) 등 주요 산업 프로토콜에 대한 성숙한 오픈소스 라이브러리가 이미 존재합니다. 바닥부터 개발할 필요가 없습니다.

### Docker를 활용한 완벽한 격리

서로 다른 프로토콜 라이브러리 간의 의존성 충돌(예: Python 버전 차이, C++ 라이브러리 충돌) 문제는 Docker 컨테이너 격리를 통해 완벽하게 해결됩니다.

이는 Modbus용 컨테이너와 BACnet용 컨테이너가 서로 독립적으로 동작함을 의미하며, 하나의 프로토콜이 다운되어도 전체 시스템에 영향을 주지 않는 견고한 아키텍처를 보장합니다.
